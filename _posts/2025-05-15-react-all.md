---
layout: post
title: 'React18 源码解析'
subtitle: '架构演进与实现原理'
date: 2025-05-15
author: 'ZhuLang'
header-img: 'img/home-bg-o.jpg'
catalog: true
tags:
  - React
  - 源码分析
  - 架构设计
  - Fiber
  - Concurrent Mode
  - Hooks
---

> 本文将从 React 15 到 18 的架构演进出发，深入分析其核心设计思想与实现原理。通过对比各版本差异，揭示 React 如何解决 UI 更新的性能瓶颈，以及未来发展方向。

## 目录

- [一、React 架构演进](#一react-架构演进)
  - [1.1 核心设计哲学](#11-核心设计哲学)
  - [1.2 版本对比](#12-版本对比)
  - [1.3 性能优化效果](#13-性能优化效果)
- [二、Fiber 架构深度解析](#二fiber-架构深度解析)
  - [2.1 Fiber 节点设计](#21-fiber-节点设计)
  - [2.2 双缓冲与并发更新](#22-双缓冲与并发更新)
- [三、调度系统](#三调度系统)
  - [3.1 优先级模型](#31-优先级模型)
  - [3.2 调度器实现](#32-调度器实现)
  - [3.3 性能优化策略](#33-性能优化策略)
- [四、React 18 并发模式](#四react-18-并发模式)
  - [4.1 自动批处理](#41-自动批处理)
  - [4.2 Transition API](#42-transition-api)
  - [4.3 Suspense 与流式 SSR](#43-suspense-与流式-ssr)
- [五、手写简易 React 16](#五手写简易-react-16)
  - [5.1 实现 createElement](#51-实现-createelement)
  - [5.2 实现 Fiber 架构核心](#52-实现-fiber-架构核心)
- [六、性能优化实战](#六性能优化实战)
  - [6.1 使用 useMemo 和 useCallback](#61-使用-usememo-和-usecallback)
  - [6.2 使用 React.memo 优化渲染](#62-使用-reactmemo-优化渲染)
- [七、React 未来展望](#七react-未来展望)
- [总结](#总结)
- [参考资料](#参考资料)

## 代码示例索引

- [调度器核心代码](#322-调度器核心实现)
- [Fiber 节点结构](#21-fiber-节点设计)
- [性能优化示例](#61-使用-usememo-和-usecallback)

## 一、React 架构演进

### 1.1 核心设计哲学

React 的架构演进始终围绕三个核心目标：

1. **声明式编程**：开发者只需关注 UI 的最终状态，而非具体实现
2. **组件化**：高内聚、低耦合的组件设计
3. **高性能**：最小化 DOM 操作，优化渲染性能

这种设计哲学直接影响了 React 的架构选择，特别是在处理更新和渲染策略上。

### 1.2 版本对比

#### React 15（2015）

- **架构**：Stack Reconciler（堆栈协调器）
- **特点**：
  - 同步递归更新
  - 不可中断的渲染过程
  - 组件树级别的更新
- **问题**：
  - 主线程阻塞
  - 无法实现时间切片
  - 更新粒度较粗

#### React 16（2017）

- **架构**：Fiber 架构
- **新特性**：
  - 可中断的异步渲染
  - 优先级调度
  - 错误边界
- **改进**：
  - 更细粒度的更新控制
  - 更好的错误处理

#### React 17（2020）

- **重点**：渐进式升级
- **变更**：
  - 新 JSX 转换
  - 事件委托重构
  - 副作用清理时机调整

#### React 18（2022）

- **核心**：并发特性
- **功能**：
  - 自动批处理
  - Transition API
  - Suspense SSR
  - 并发渲染

### 1.3 性能优化效果

| 场景     | React 15   | React 18 | 提升   |
| -------- | ---------- | -------- | ------ |
| 首次加载 | 1200ms     | 800ms    | 33%    |
| 输入响应 | 150ms      | 30ms     | 80%    |
| 页面切换 | 完整重渲染 | 部分更新 | 50-70% |
| 内存占用 | 高         | 显著降低 | ~40%   |

## 二、Fiber 架构深度解析

### 2.1 Fiber 节点设计

```typescript
interface Fiber {
  // 实例相关
  tag: WorkTag; // 组件类型
  key: null | string; // 同级节点唯一标识
  elementType: any; // 组件类型
  type: any; // 与elementType相同（除lazy组件）
  stateNode: any; // 对应的实例/DOM节点

  // 链表结构
  return: Fiber | null; // 父节点
  child: Fiber | null; // 第一个子节点
  sibling: Fiber | null; // 下一个兄弟节点
  index: number; // 在父节点中的索引
  ref: any; // ref引用

  // 状态相关
  pendingProps: any; // 新传入的props
  memoizedProps: any; // 上次渲染的props
  updateQueue: mixed; // 更新队列
  memoizedState: any; // 上次渲染的state
  dependencies: Dependencies | null; // 上下文/refs

  // 副作用
  flags: Flags; // 副作用标记
  subtreeFlags: Flags; // 子树副作用标记
  deletions: Array<Fiber> | null; // 待删除的子节点

  // 调度优先级
  lanes: Lanes; // 当前更新优先级
  childLanes: Lanes; // 子树更新优先级

  // 双缓存
  alternate: Fiber | null; // 指向workInProgress树对应节点
}
```

### 2.2 双缓冲与并发更新

React 使用双缓冲技术实现无闪烁更新：

1. **current 树**：当前显示在屏幕上的树
2. **workInProgress 树**：正在内存中构建的新树

**更新流程**：

1. 从根节点开始构建 workInProgress 树
2. 比较 current 树和 workInProgress 树生成副作用列表
3. 提交阶段将变更应用到 DOM
4. 完成后 workInProgress 树变为 current 树

## 三、调度系统

### 3.1 优先级模型

#### 3.1.1 优先级类型

- **Immediate**：同步任务，如用户输入
- **User-blocking**：动画、手势等
- **Normal**：数据获取、更新 UI
- **Low**：分析、日志记录
- **Idle**：非关键任务

### 3.2 调度器实现

#### 3.2.1 调度器核心实现

```typescript
// 任务队列
type Task = {
  id: number;
  callback: (didTimeout?: boolean) => any;
  priorityLevel: PriorityLevel;
  startTime: number;
  expirationTime: number;
  sortIndex: number;
};

function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: { delay?: number }
): Task {
  const currentTime = getCurrentTime();
  const startTime = options?.delay ? currentTime + options.delay : currentTime;

  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = -1;
      break;
    case UserBlockingPriority:
      timeout = 250;
      break;
    case IdlePriority:
      timeout = 1073741823;
      break;
    case LowPriority:
      timeout = 10000;
      break;
    default:
      timeout = 5000; // NormalPriority
  }

  const expirationTime = startTime + timeout;
  const newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };

  if (startTime > currentTime) {
    // 延迟任务处理
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
  } else {
    // 立即执行任务
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

### 3.3 性能优化策略

#### 3.3.1 使用 React.memo

```jsx
const MemoizedComponent = React.memo(
  (props) => <ExpensiveComponent {...props} />,
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    return prevProps.value === nextProps.value;
  }
);
```

#### 3.3.2 使用 useMemo 和 useCallback

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(count);
  }, [count]);

  const handleClick = useCallback(() => {
    setCount((c) => c + 1);
  }, []);

  return <Child value={expensiveValue} onClick={handleClick} />;
}
```

## 四、最佳实践

### 4.1 性能优化

- 使用 `React.memo` 避免不必要的重渲染
- 合理使用 `useMemo` 和 `useCallback`
- 避免在渲染函数中执行高开销计算

### 4.2 代码分割

```jsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

### 4.3 状态管理

- 使用 Context + useReducer 管理全局状态
- 考虑使用状态管理库（如 Redux, MobX）
- 合理划分状态作用域

## 五、未来发展方向

1. **Server Components**

   - 服务端组件（零包大小）
   - 自动代码分割
   - 数据获取与渲染并行

2. **Offscreen Rendering**
   - 后台预渲染
   - 保持组件状态
   - 优化页面切换性能

## 六、总结

React 的架构演进始终围绕着提升用户体验和开发者体验展开。从最初的同步渲染到现在的并发渲染，React 通过不断创新来解决前端开发的痛点。未来，随着 Server Components 等新特性的成熟，React 将继续引领前端开发的潮流。

React 15 采用**同步递归更新**的 Stack Reconciler，其核心问题在于：

1. **不可中断的递归**：深度优先遍历整棵树，无法中断
2. **主线程阻塞**：大型应用导致 UI 卡顿
3. **更新粒度粗**：以组件树为单位更新，无法实现细粒度控制

```jsx
// 同步渲染模式
ReactDOM.render(<App />, document.getElementById('root'));
```

### 1.2 React 16 的 Fiber 架构（2017 年）

React 16 引入的 Fiber 架构是对核心协调算法的重写，主要解决以下问题：

1. **可中断的异步渲染**：将递归遍历改为链表遍历
2. **优先级调度**：基于`expirationTime`的优先级模型
3. **双缓存机制**：current 树与 workInProgress 树交替更新
4. **错误边界**：组件级别的错误捕获

#### 关键实现细节

```typescript
// 启用并发模式
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);

// 时间切片实现
function workLoop(deadline) {
  let shouldYield = false;
  while (nextUnitOfWork && !shouldYield) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
    shouldYield = deadline.timeRemaining() < 1;
  }

  if (!nextUnitOfWork && wipRoot) {
    commitRoot();
  }

  requestIdleCallback(workLoop);
}

// 每个工作单元处理
function performUnitOfWork(fiber) {
  // 1. 执行当前工作单元
  const isFunctionComponent = fiber.type instanceof Function;
  if (isFunctionComponent) {
    updateFunctionComponent(fiber);
  } else {
    updateHostComponent(fiber);
  }

  // 2. 返回下一个工作单元
  if (fiber.child) return fiber.child;
  let nextFiber = fiber;
  while (nextFiber) {
    if (nextFiber.sibling) return nextFiber.sibling;
    nextFiber = nextFiber.return;
  }
}
```

**性能优化**：

- 将渲染工作分解成小任务（通常 5ms）
- 使用`requestIdleCallback`在浏览器空闲时执行任务
- 支持任务中断和恢复

React 16 引入 Fiber 架构，核心改进：

1. **可中断的异步渲染**：将递归遍历改为链表遍历
2. **优先级调度**：基于`expirationTime`的优先级模型
3. **双缓存机制**：current 树与 workInProgress 树交替更新

```jsx
// 启用异步渲染模式
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<App />);
```

### 1.3 React 17 的渐进式升级（2020 年）

React 17 是一个"垫脚石"版本，主要目标是实现渐进式升级：

1. **事件委托重构**

   - 从 `document` 改为挂载到根容器
   - 解决多版本 React 共存时的事件冲突
   - 改进与微前端的兼容性

2. **新的 JSX 转换**

   ```jsx
   // 旧转换
   import React from 'react';

   function App() {
     return React.createElement('h1', null, 'Hello World');
   }

   // 新转换（自动引入）
   import { jsx as _jsx } from 'react/jsx-runtime';

   function App() {
     return _jsx('h1', { children: 'Hello World' });
   }
   ```

3. **优先级模型调整**

   - 为后续的并发特性做准备
   - 引入更细粒度的优先级控制
   - 改进批量更新的处理逻辑

4. **Effect 清理时机**

   ```jsx
   // React 16: 清理函数在 commit 阶段同步执行
   // React 17: 清理函数异步执行（与浏览器渲染并行）
   useEffect(() => {
     // 副作用代码
     return () => {
       // 清理函数
     };
   }, []);
   ```

5. **事件委托重构**：事件委托到根容器而非 document
6. **JSX 转换优化**：新的 JSX 转换器（`_jsx`/`_jsxs`）
7. **优先级模型调整**：为 Lane 模型做准备

### 1.4 React 18 的并发特性（2022 年）

React 18 标志着并发特性的正式落地，主要特性包括：

#### 1. 自动批处理（Automatic Batching）

```jsx
// React 17 及之前：
setTimeout(() => {
  setCount((c) => c + 1);
  setFlag((f) => !f);
  // 导致两次渲染
}, 1000);

// React 18：
setTimeout(() => {
  setCount((c) => c + 1);
  setFlag((f) => !f);
  // 自动批处理为一次渲染
}, 1000);
```

#### 2. Transition API

```jsx
import { startTransition } from 'react';

// 标记为非紧急更新
startTransition(() => {
  setSearchQuery(input);
});

// 使用 useTransition 获取状态
const [isPending, startTransition] = useTransition();

return (
  <div>
    {isPending && <Spinner />}
    <Results query={query} />
  </div>
);
```

#### 3. Suspense for Data Fetching

```jsx
// 使用 Suspense 处理数据获取
function ProfilePage() {
  return (
    <Suspense fallback={<h1>Loading profile...</h1>}>
      <ProfileDetails />
      <Suspense fallback={<h1>Loading posts...</h1>}>
        <ProfileTimeline />
      </Suspense>
    </Suspense>
  );
}

// 在组件中直接使用异步数据
function ProfileDetails() {
  const user = fetchUserData(); // 抛出 Promise
  return <h1>{user.name}</h1>;
}
```

#### 4. 流式 SSR（Server Components）

```jsx
// 服务端组件 (ServerComponent.server.js)
export default function Note({id}) {
  const note = db.notes.get(id);
  return (
    <div>
      <h1>{note.title}</h1>
      <section>{note.content}</section>
      <LikeButton noteId={id} />
    </div>
  );
}

// 客户端组件 (LikeButton.client.js)
'use client';

export default function LikeButton({noteId}) {
  const [liked, setLiked] = useState(false);

  if (liked) {
    return 'You liked this note!';
  }

  return <button onClick={() => setLiked(true)}>Like</button>;
}
```

#### 性能优化效果

| 场景     | React 16   | React 18 | 提升   |
| -------- | ---------- | -------- | ------ |
| 首次加载 | 1200ms     | 800ms    | 33%    |
| 输入响应 | 150ms      | 30ms     | 80%    |
| 页面切换 | 完整重渲染 | 部分更新 | 50-70% |
| 内存占用 | 高         | 显著降低 | ~40%   |

1. **自动批处理**：setState 自动合并
2. **Transition API**：区分紧急/非紧急更新
3. **Suspense SSR**：流式服务端渲染
4. **并发渲染**：可中断的渲染过程

## 二、Fiber 架构深度解析

### 2.1 Fiber 节点设计

Fiber 是 React 16+ 的核心架构，其设计目标包括：

1. **可中断性**：将渲染工作分解为小任务单元
2. **可恢复性**：保存工作进度，支持断点续传
3. **优先级**：支持不同优先级的更新
4. **并发性**：支持并发模式的渲染

#### Fiber 节点关键字段解析

```typescript
interface Fiber {
  // 1. 实例相关
  tag: WorkTag; // 组件类型（函数/类组件等）
  key: null | string; // 同级节点唯一标识
  elementType: any; // 组件类型（函数/类）
  type: any; // 与elementType相同（除lazy组件）
  stateNode: any; // 对应的实例/DOM节点

  // 2. 链表结构
  return: Fiber | null; // 父节点
  child: Fiber | null; // 第一个子节点
  sibling: Fiber | null; // 下一个兄弟节点
  index: number; // 在父节点中的索引
  ref: any; // ref引用

  // 3. 状态相关
  pendingProps: any; // 新传入的props
  memoizedProps: any; // 上次渲染的props
  updateQueue: mixed; // 更新队列
  memoizedState: any; // 上次渲染的state
  dependencies: Dependencies | null; // 上下文/refs

  // 4. 副作用
  flags: Flags; // 副作用标记（新增/更新/删除）
  subtreeFlags: Flags; // 子树副作用标记
  deletions: Array<Fiber> | null; // 待删除的子节点

  // 5. 调度优先级
  lanes: Lanes; // 当前更新优先级
  childLanes: Lanes; // 子树更新优先级

  // 6. 双缓存
  alternate: Fiber | null; // 指向workInProgress树对应节点

  // 7. 性能分析
  actualDuration?: number; // 本次渲染耗时
  actualStartTime?: number; // 开始渲染时间
  selfBaseDuration?: number; // 当前组件渲染耗时
  treeBaseDuration?: number; // 整棵子树渲染耗时
}
```

### 2.2 双缓冲与并发更新

React 使用双缓冲技术实现无闪烁更新：

1. **current 树**：当前显示在屏幕上的树
2. **workInProgress 树**：正在内存中构建的新树

**更新流程**：

```typescript
// 1. 开始渲染（render阶段）
function renderRootSync(root: FiberRoot, lanes: Lanes) {
  // 创建workInProgress树
  prepareFreshStack(root, lanes);

  // 开始工作循环
  workLoopSync();

  // 提交更新
  const finishedWork = root.current.alternate;
  commitRoot(root, finishedWork);
}

// 2. 工作循环
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// 3. 执行工作单元
function performUnitOfWork(unitOfWork: Fiber): void {
  const current = unitOfWork.alternate;

  // 开始工作（beginWork会返回下一个工作单元）
  const next = beginWork(current, unitOfWork, renderLanes);

  // 重置工作单元属性
  unitOfWork.memoizedProps = unitOfWork.pendingProps;

  if (next === null) {
    // 没有子节点，完成当前节点
    completeUnitOfWork(unitOfWork);
  } else {
    workInProgress = next;
  }
}

// 4. 完成工作单元
function completeUnitOfWork(unitOfWork: Fiber): void {
  let completedWork = unitOfWork;

  do {
    const current = completedWork.alternate;
    const returnFiber = completedWork.return;

    // 完成当前节点工作
    const next = completeWork(current, completedWork, renderLanes);

    // 重置子优先级
    if (returnFiber !== null) {
      if (returnFiber.firstEffect === null) {
        returnFiber.firstEffect = completedWork.firstEffect;
      }
      if (completedWork.lastEffect !== null) {
        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = completedWork.firstEffect;
        }
        returnFiber.lastEffect = completedWork.lastEffect;
      }

      // 收集副作用
      const flags = completedWork.flags;
      if (flags > PerformedWork) {
        if (returnFiber.lastEffect !== null) {
          returnFiber.lastEffect.nextEffect = completedWork;
        } else {
          returnFiber.firstEffect = completedWork;
        }
        returnFiber.lastEffect = completedWork;
      }
    }

    // 处理兄弟节点
    const siblingFiber = completedWork.sibling;
    if (siblingFiber !== null) {
      workInProgress = siblingFiber;
      return;
    }

    // 回溯到父节点
    completedWork = returnFiber;
    workInProgress = completedWork;
  } while (completedWork !== null);
}
```

**性能优化技巧**：

1. 使用 `React.memo` 避免不必要的重渲染
2. 合理使用 `useMemo` 和 `useCallback` 缓存计算结果和回调
3. 使用 `React.lazy` 和 `Suspense` 实现代码分割
4. 避免在渲染函数中执行高开销计算
5. 使用 `React DevTools Profiler` 分析性能瓶颈

### 2.1 Fiber 节点设计

```typescript
interface Fiber {
  // 基础属性
  tag: WorkTag; // 组件类型（函数/类组件等）
  key: null | string; // 同级节点唯一标识
  elementType: any; // 组件类型
  type: any; // 与elementType相同（除lazy组件）
  stateNode: any; // 对应的实例/DOM节点

  // 链表结构
  return: Fiber | null; // 父节点
  child: Fiber | null; // 第一个子节点
  sibling: Fiber | null; // 下一个兄弟节点
  index: number; // 在父节点中的索引

  // 状态相关
  pendingProps: any; // 新传入的props
  memoizedProps: any; // 上次渲染的props
  updateQueue: mixed; // 更新队列
  memoizedState: any; // 上次渲染的state
  dependencies: Dependencies | null; // 上下文/refs

  // 副作用
  flags: Flags; // 副作用标记
  subtreeFlags: Flags; // 子树副作用标记
  deletions: Array<Fiber> | null; // 待删除的子节点

  // 调度优先级
  lanes: Lanes; // 当前更新优先级
  childLanes: Lanes; // 子树更新优先级

  // 双缓存
  alternate: Fiber | null; // 指向workInProgress树对应节点
}
```

### 2.2 双缓冲与并发更新

React 使用双缓冲技术实现无闪烁更新：

1. **current 树**：当前显示在屏幕上的树
2. **workInProgress 树**：正在内存中构建的新树

更新流程：

1. 从根节点开始构建 workInProgress 树
2. 比较 current 树和 workInProgress 树生成副作用列表
3. 提交阶段将变更应用到 DOM
4. 完成后 workInProgress 树变为 current 树

## 三、调度系统（Scheduler）深度解析

### 3.1 优先级模型

#### 3.1.1 优先级类型

- **Immediate**：同步任务，如用户输入
- **User-blocking**：动画、手势等
- **Normal**：数据获取、更新 UI
- **Low**：分析、日志记录
- **Idle**：非关键任务

#### 3.1.2 优先级模型演进

**React 16：expirationTime 模型**

```typescript
// 基于时间戳的优先级计算
const HIGH_PRIORITY_EXPIRATION = 150; // 150ms
const LOW_PRIORITY_EXPIRATION = 5000; // 5s

function computeExpirationTime(currentTime, priorityLevel) {
  switch (priorityLevel) {
    case ImmediatePriority:
      return currentTime - 1; // 立即执行
    case UserBlockingPriority:
      return currentTime + HIGH_PRIORITY_EXPIRATION;
    case NormalPriority:
    default:
      return currentTime + LOW_PRIORITY_EXPIRATION;
  }
}
```

**React 17+：Lane 模型**

```typescript
// 基于二进制的优先级表示（31位）
export const NoLanes: Lanes = 0b0000000000000000000000000000000;
export const SyncLane: Lane = 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = 0b0000000000000000000000000001000;
export const DefaultLane: Lane = 0b0000000000000000000000000100000;

// 合并多个优先级
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}

// 判断是否包含某个优先级
export function includesSomeLane(a: Lanes | Lane, b: Lanes | Lane): boolean {
  return (a & b) !== NoLanes;
}
```

**Lane 模型优势**：

1. 更细粒度的优先级控制
2. 支持多个并行的更新批次
3. 更精确的更新追踪

### 3.2 调度器核心实现

```typescript
// 任务队列
type Task = {
  id: number;
  callback: (didTimeout?: boolean) => any;
  priorityLevel: PriorityLevel;
  startTime: number;
  expirationTime: number;
  sortIndex: number;
};

// 调度器核心逻辑
function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: { delay?: number }
): Task {
  const currentTime = getCurrentTime();

  // 1. 计算任务开始时间
  const startTime = options?.delay ? currentTime + options.delay : currentTime;

  // 2. 设置超时时间
  const timeout = {
    [ImmediatePriority]: -1, // 立即执行，最高优先级
    [UserBlockingPriority]: 250, // 250ms，用户交互相关
    [NormalPriority]: 5000, // 5s，普通更新
    [LowPriority]: 10000, // 10s，低优先级更新
    [IdlePriority]: 1073741823, // 空闲时执行，最大安全整数
  }[priorityLevel];

  const expirationTime = startTime + timeout;

  // 3. 创建新任务
  const newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };

  // 4. 将任务加入队列
  if (startTime > currentTime) {
    // 延迟任务
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
  } else {
    // 立即执行任务
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);

    // 开始调度
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

### 3.3 时间切片实现

React 使用 `MessageChannel` 实现时间切片，确保主线程不会被长时间占用：

```typescript
const channel = new MessageChannel();
const port = channel.port2;

// 请求主线程回调
requestHostCallback = function (callback) {
  scheduledHostCallback = callback;

  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    port.postMessage(null);
  }
};

// 处理回调
channel.port1.onmessage = function () {
  if (scheduledHostCallback === null) {
    isMessageLoopRunning = false;
    return;
  }

  const currentTime = getCurrentTime();
  const hasTimeRemaining = true;

  // 执行工作直到时间片结束
  const hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);

  // 如果还有工作，继续调度
  if (hasMoreWork) {
    port.postMessage(null);
  } else {
    isMessageLoopRunning = false;
    scheduledHostCallback = null;
  }
};

// 检查是否需要让出主线程
function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;
  return timeElapsed > frameInterval; // 默认5ms
}
```

### 3.4 性能优化策略

1. **使用 React.memo 避免不必要的重渲染**

```jsx
const MemoizedComponent = React.memo(
  (props) => <ExpensiveComponent {...props} />,
  (prevProps, nextProps) => {
    // 自定义比较逻辑
    return prevProps.value === nextProps.value;
  }
);
```

2. **使用 useMemo 和 useCallback 优化性能**

```jsx
function Parent() {
  const [count, setCount] = useState(0);

  // 缓存计算结果
  const expensiveValue = useMemo(() => {
    return computeExpensiveValue(count);
  }, [count]);

  // 缓存回调函数
  const handleClick = useCallback(() => {
    setCount((c) => c + 1);
  }, []);

  return <Child value={expensiveValue} onClick={handleClick} />;
}
```

3. **代码分割与懒加载**

```jsx
const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <LazyComponent />
    </Suspense>
  );
}
```

4. **使用 React DevTools 分析性能**
   - 识别不必要的重渲染
   - 分析组件更新原因
   - 测量渲染时间

### 3.3 调度器优化策略

1. **任务优先级**：

   - 立即执行（Immediate）：同步任务，如用户输入
   - 用户阻塞（User-blocking）：动画、手势等
   - 普通（Normal）：数据获取、更新 UI
   - 低优先级（Low）：分析、日志记录
   - 空闲（Idle）：非关键任务

2. **时间切片**：

   - 默认 5ms 一个时间片
   - 使用`shouldYieldToHost`检查是否需要让出主线程
   - 通过`requestIdleCallback`或`MessageChannel`实现

3. **批量更新**：

   ```jsx
   // React 18 自动批处理
   function handleClick() {
     setName('New Name');
     setAge(30);
     // 只触发一次渲染
   }

   // 手动批处理（旧版本）
   import { unstable_batchedUpdates } from 'react-dom';

   function handleClick() {
     unstable_batchedUpdates(() => {
       setName('New Name');
       setAge(30);
     });
   }
   ```

4. **并发模式下的更新优先级**：

   ```jsx
   import { startTransition } from 'react';

   // 低优先级更新
   startTransition(() => {
     setSearchQuery(input);
   });

   // 高优先级更新（立即执行）
   setInputValue(input);
   ```

5. **Suspense 与并发渲染**：

   ```jsx
   function ProfilePage() {
     return (
       <Suspense fallback={<h1>Loading profile...</h1>}>
         <ProfileDetails />
         <Suspense fallback={<h1>Loading posts...</h1>}>
           <ProfileTimeline />
         </Suspense>
       </Suspense>
     );
   }

   // 数据获取
   function ProfileDetails() {
     const user = fetchUserData(); // 抛出 Promise
     return <h1>{user.name}</h1>;
   }
   ```

### 3.4 性能监控与调优

1. **使用 React DevTools Profiler**：

   - 记录组件渲染时间
   - 分析组件更新原因
   - 识别不必要的重渲染

2. **使用 React.memo 优化**：

   ```jsx
   const MyComponent = React.memo(function MyComponent(props) {
     // 组件代码
   }, areEqual);

   // 自定义比较函数
   function areEqual(prevProps, nextProps) {
     // 返回 true 表示不重新渲染
     // 返回 false 表示需要重新渲染
   }
   ```

3. **使用 useMemo 和 useCallback**：

   ```jsx
   function Parent() {
     const [count, setCount] = useState(0);

     // 缓存计算结果
     const expensiveValue = useMemo(() => {
       return computeExpensiveValue(count);
     }, [count]);

     // 缓存回调函数
     const handleClick = useCallback(() => {
       setCount((c) => c + 1);
     }, []);

     return <Child onClick={handleClick} value={expensiveValue} />;
   }
   ```

4. **使用 React.lazy 和 Suspense 实现代码分割**：

   ```jsx
   const OtherComponent = React.lazy(() => import('./OtherComponent'));

   function MyComponent() {
     return (
       <div>
         <Suspense fallback={<div>Loading...</div>}>
           <OtherComponent />
         </Suspense>
       </div>
     );
   }
   ```

5. **使用 useDeferredValue 优化输入响应**：

   ```jsx
   function SearchResults({ query }) {
     const deferredQuery = useDeferredValue(query);

     // 当 query 变化时，先显示旧结果，再在后台更新
     return (
       <div>
         <Results query={deferredQuery} />
       </div>
     );
   }
   ```

### 3.5 未来发展方向

1. **Server Components**：

   - 服务端组件（零包大小）
   - 自动代码分割
   - 数据获取与渲染并行

2. **Offscreen Rendering**：

   - 后台预渲染
   - 保持组件状态
   - 优化页面切换性能

3. **Transition Tracing**：

   - 跟踪更新来源
   - 性能瓶颈分析
   - 优化用户体验

4. **资源提示**：
   - 预加载关键资源
   - 智能预取
   - 优化首屏加载

### 3.1 优先级模型演进

#### React 16：expirationTime 模型

```typescript
// 基于时间戳的优先级计算
const HIGH_PRIORITY_EXPIRATION = 150; // 150ms
const LOW_PRIORITY_EXPIRATION = 5000; // 5s

function computeExpirationTime(currentTime, priorityLevel) {
  switch (priorityLevel) {
    case ImmediatePriority:
      return currentTime - 1; // 立即执行
    case UserBlockingPriority:
      return currentTime + HIGH_PRIORITY_EXPIRATION;
    case NormalPriority:
    default:
      return currentTime + LOW_PRIORITY_EXPIRATION;
  }
}
```

#### React 17+：Lane 模型

```typescript
// 基于二进制的优先级表示
export const NoLanes: Lanes = 0b0000000000000000000000000000000;
export const SyncLane: Lane = 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = 0b0000000000000000000000000001000;
export const DefaultLane: Lane = 0b0000000000000000000000000100000;

// 合并多个优先级
export function mergeLanes(a: Lanes | Lane, b: Lanes | Lane): Lanes {
  return a | b;
}
```

### 3.2 调度器实现

```typescript
// 任务队列
type Task = {
  id: number;
  callback: (didTimeout?: boolean) => any;
  priorityLevel: PriorityLevel;
  startTime: number;
  expirationTime: number;
  sortIndex: number;
};

// 调度器核心逻辑
function unstable_scheduleCallback(
  priorityLevel: PriorityLevel,
  callback: Callback,
  options?: { delay?: number }
): Task {
  const currentTime = getCurrentTime();

  // 1. 计算任务开始时间和过期时间
  let startTime;
  if (typeof options === 'object' && options !== null) {
    const delay = options.delay;
    if (typeof delay === 'number' && delay > 0) {
      startTime = currentTime + delay;
    } else {
      startTime = currentTime;
    }
  } else {
    startTime = currentTime;
  }

  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250ms
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT; // 1073741823ms
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT; // 10000ms
      break;
    case NormalPriority:
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT; // 5000ms
      break;
  }

  const expirationTime = startTime + timeout;

  // 2. 创建新任务
  const newTask: Task = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    startTime,
    expirationTime,
    sortIndex: -1,
  };

  // 3. 将任务加入对应队列
  if (startTime > currentTime) {
    // 延迟任务
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
      if (isHostTimeoutScheduled) {
        cancelHostTimeout();
      } else {
        isHostTimeoutScheduled = true;
      }
      requestHostTimeout(handleTimeout, startTime - currentTime);
    }
  } else {
    // 立即执行任务
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
    if (!isHostCallbackScheduled && !isPerformingWork) {
      isHostCallbackScheduled = true;
      requestHostCallback(flushWork);
    }
  }

  return newTask;
}
```

## 四、React 18 并发模式深度解析

### 4.1 自动批处理（Automatic Batching）

```jsx
// React 17 及之前
setTimeout(() => {
  setCount((c) => c + 1);
  setFlag((f) => !f);
  // 触发两次渲染
}, 1000);

// React 18
setTimeout(() => {
  setCount((c) => c + 1);
  setFlag((f) => !f);
  // 只触发一次渲染（自动批处理）
}, 1000);
```

### 4.2 Transition API

```jsx
import { startTransition } from 'react';

// 紧急更新：立即执行
setInputValue(input);

// 非紧急更新：可中断
tartTransition(() => {
  setSearchQuery(input);
});
```

### 4.3 Suspense 与流式 SSR

```jsx
// 服务端
const { pipe } = renderToPipeableStream(<App />, {
  onShellReady() {
    res.setHeader('Content-type', 'text/html');
    pipe(res);
  },
  onShellError(error) {
    console.error('Failed to render shell:', error);
    res.statusCode = 500;
    res.end('Error rendering page');
  },
});

// 客户端
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <Suspense fallback={<Spinner />}>
    <App />
  </Suspense>
);
```

## 五、手写简易 React 16

### 5.1 实现 createElement

```jsx
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map((child) =>
        typeof child === 'object' ? child : createTextElement(child)
      ),
    },
  };
}

function createTextElement(text) {
  return {
    type: 'TEXT_ELEMENT',
    props: {
      nodeValue: text,
      children: [],
    },
  };
}
```

### 5.2 实现 Fiber 架构核心

```jsx
// 1. 创建DOM
function createDom(fiber) {
  const dom =
    fiber.type === 'TEXT_ELEMENT'
      ? document.createTextNode('')
      : document.createElement(fiber.type);

  updateDom(dom, {}, fiber.props);
  return dom;
}

// 2. 协调阶段
function reconcileChildren(wipFiber, elements) {
  let index = 0;
  let oldFiber = wipFiber.alternate && wipFiber.alternate.child;
  let prevSibling = null;

  while (index < elements.length || oldFiber != null) {
    const element = elements[index];
    let newFiber = null;

    // 比较新旧Fiber
    const sameType = oldFiber && element && element.type === oldFiber.type;

    if (sameType) {
      // 更新节点
      newFiber = {
        type: oldFiber.type,
        props: element.props,
        dom: oldFiber.dom,
        parent: wipFiber,
        alternate: oldFiber,
        effectTag: 'UPDATE',
      };
    }
    if (element && !sameType) {
      // 新增节点
      newFiber = {
        type: element.type,
        props: element.props,
        dom: null,
        parent: wipFiber,
        alternate: null,
        effectTag: 'PLACEMENT',
      };
    }
    if (oldFiber && !sameType) {
      // 删除节点
      oldFiber.effectTag = 'DELETION';
      deletions.push(oldFiber);
    }

    if (oldFiber) {
      oldFiber = oldFiber.sibling;
    }

    if (index === 0) {
      wipFiber.child = newFiber;
    } else if (element) {
      prevSibling.sibling = newFiber;
    }

    prevSibling = newFiber;
    index++;
  }
}

// 3. 提交阶段
function commitRoot() {
  deletions.forEach(commitWork);
  commitWork(wipRoot.child);
  currentRoot = wipRoot;
  wipRoot = null;
}

function commitWork(fiber) {
  if (!fiber) return;

  let domParentFiber = fiber.parent;
  while (!domParentFiber.dom) {
    domParentFiber = domParentFiber.parent;
  }
  const domParent = domParentFiber.dom;

  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {
    domParent.appendChild(fiber.dom);
  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {
    updateDom(fiber.dom, fiber.alternate.props, fiber.props);
  } else if (fiber.effectTag === 'DELETION') {
    commitDeletion(fiber, domParent);
  }

  commitWork(fiber.child);
  commitWork(fiber.sibling);
}
```

## 六、性能优化实战

### 6.1 使用 useMemo 和 useCallback

```jsx
function HeavyComponent({ items, onSelect }) {
  // 使用useMemo缓存计算结果
  const processedItems = useMemo(() => {
    return items.map((item) => ({
      ...item,
      processed: heavyComputation(item),
    }));
  }, [items]);

  // 使用useCallback缓存回调
  const handleSelect = useCallback(
    (id) => {
      onSelect(id);
    },
    [onSelect]
  );

  return (
    <ul>
      {processedItems.map((item) => (
        <li key={item.id} onClick={() => handleSelect(item.id)}>
          {item.name}
        </li>
      ))}
    </ul>
  );
}
```

### 6.2 使用 React.memo 和 useMemo 优化渲染

```jsx
const ExpensiveComponent = React.memo(
  ({ value }) => {
    // 只有value变化时才会重新渲染
    return <div>{value}</div>;
  },
  (prevProps, nextProps) => {
    // 自定义比较函数
    return prevProps.value === nextProps.value;
  }
);

function Parent() {
  const [state, setState] = useState({});

  // 使用useMemo避免不必要的重新创建
  const memoizedValue = useMemo(
    () => ({
      key: 'value',
    }),
    []
  );

  return (
    <div>
      <button onClick={() => setState({})}>Force Update</button>
      <ExpensiveComponent value={memoizedValue} />
    </div>
  );
}
```

## 七、React 未来展望

1. **Server Components**：服务端组件
2. **Offscreen Rendering**：后台预渲染
3. **Asset Loading**：资源加载优化
4. **Web Components 集成**：更好的互操作性

## 总结

React 的架构演进始终围绕着**性能**和**开发体验**两个核心：

1. **Fiber 架构**：实现可中断的异步渲染
2. **并发模式**：优化用户交互体验
3. **自动批处理**：减少不必要的渲染
4. **Suspense**：统一数据获取和代码分割

> 本文由[逐浪前端](https://github.com/blackWhiteAndGray)原创，转载请注明出处。

## 参考资料

1. [React 官方文档](https://reactjs.org/)
2. [React 源码解析](https://github.com/7kms/react-illustration-series)
3. [React 技术揭秘](https://react.iamkasong.com/)
4. [React RFCs](https://github.com/reactjs/rfcs)
5. [React 18 升级指南](https://reactjs.org/blog/2022/03/08/react-18-upgrade-guide.html)
